<html>

<head>

</head>

<body>
    <div id="main-container">
        <div id="menu">
            <button id="run-btn">RUN</button>
            <a href="configManualBuilderN2.html">Config Manual Builder N=2</a>
            <a href="configManualBuilderN3.html">Config Manual Builder N=3</a>
            <a href="refinementFactory.html">Refinement Factory N=3</a> 
            <a href="tryToFindNewArrangments.html">Try to find new arrangments N=3</a> 
        </div>
        <svg id="zone" height="1" width="1" style="border:3px solid blue"></svg> 
    </div>
    <script type="module">

        //idee optimisation: pre calculer tous les gabari de carres (avec scales et rotations) puis les translater
        import { createSVGSquare, updateSVGSquare, drawPoint, drawBox } from './draw.mjs';
        import { MIN, MAX, W, H, NB_SQUARE, NB_VERTEX, COS, SIN } from './constants.mjs';
        //import { arrangement_to_VI } from './calculVI.mjs';
        import { are_VI_Equivalents } from './compare-arrangements.mjs';
        import { getInitSquares } from './initSquares.mjs';
        import { searchArrangments_V1 } from  './searchArrangments.mjs';


        let squares = getInitSquares(); 
        document.getElementById('run-btn').addEventListener('click', function(event) {
            searchArrangments_V1(squares);
        });

        //tests
        // let V0 = [
        //     [0, 1, 2],
        //     [1, 0, 1],
        //     [0, 1, 0]
        // ]; // 0, 1, 2
        // let V1 = [
        //     [0, 0, 1],
        //     [2, 0, 1],
        //     [1, 1, 0]
        // ];//  permutation: 2, 0, 1
        // let I0 = [ 
        //     [0, 2, 1],
        //     [3, 1, 0],
        //     [1, 0, 2],
        //     [0, 1, 1],
        // ];
        // let I1 = [ 
        //     [1, 0, 1],
        //     [1, 0, 0],
        //     [0, 3, 1],
        //     [2, 1, 2],
        // ]

        // console.log(are_VI_Equivalents({V:V0, I:I0}, {V:V1, I:I1}));
        
        //Simulation
        //on place le square 0 au centre, il restera invariant
        squares[0].initRotZero(80, {x:W/2, y:H/2});
        squares[0].majBox();
        createSVGSquare(squares[0],0);

        //Les deux autre squares vont bouger    
        squares[1].initRotZero(100, {x:-9999, y:-9999});
        squares[1].majBox();
        //squares[1].translate({x:W/2, y:H/2})
        createSVGSquare(squares[1],1);

        squares[2].initRotZero(100, {x:9999,y:9999});
        squares[2].majBox();
        createSVGSquare(squares[2],2);

        //scale [0.01, 2]
        //rotation [0, 89]
        //x dans [ squares[0].box.xmin - squares[0].a/2, squares[0].box.xmax + squares[0].a/2]
        //y dans [ squares[0].box.ymin - squares[0].a/2, squares[0].box.ymax + squares[0].a/2]
        // pas x et y: squares[0].a/10; 

        // squares[0].initRotZero(100, {x:W/2, y:H/2});
        // squares[0].majBox();
        // drawSquare(squares[0]);

        // squares[1].copy(squares[0]);
        // squares[1].translate({x:40,y:40});
        // //squares[1].rotate(24);
        // drawSquare(squares[1]);

        // squares[2].copy(squares[0]);
        // //squares[2].scale(2.5);
        // squares[2].translate({x:100,y:0});
        // squares[2].rotate(45);
        // drawSquare(squares[2]);
        // console.log(squares);
    
        // let VI = arrangement_to_VI(squares);
        // console.log('VI=',VI);

        //arr 6
        // squares[1].vertex = [
        //     {x: 205.35533905932738, y: 198.76275643042055},
        //     {x: 231.23724356957945, y: 295.3553390593274},
        //     {x: 134.64466094067262, y: 321.23724356957945},
        //     {x: 108.76275643042055, y: 224.64466094067262}
        // ]

        // squares[1].box = {xmin: 108.76275643042055, xmax: 231.23724356957945, ymin: 198.76275643042055, ymax: 321.23724356957945};

        // squares[1].boxEdge = [
        //     {xmin: 205.35533905932738, xmax: 231.23724356957945, ymin: 198.76275643042055, ymax: 295.3553390593274},
        //     {xmin: 134.64466094067262, xmax: 231.23724356957945, ymin: 295.3553390593274, ymax: 321.23724356957945},
        //     {xmin: 108.76275643042055, xmax: 134.64466094067262, ymin: 224.64466094067262, ymax: 321.23724356957945},
        //     {xmin: 108.76275643042055, xmax: 205.35533905932738, ymin: 198.76275643042055, ymax: 224.64466094067262}
        // ];
        // squares[1].center = { x: 170, y: 260 };

        // let arr = arrangement_to_VI(squares);// bug !!!!

        // console.log("areEqual:"+ areEqual(V0, V2));
        // console.log("sumOnColumn:"+ sumOnColumn(V2, 0));
        // console.log("sumOnColumn:"+ sumOnColumn(V2, 1));
        // console.log("sumOnColumn:"+ sumOnColumn(V2, 2));
        // console.log("Det V0:"+ Det33(V0));
        // console.log("Det V2:"+ Det33(V2));
        
        // let EquivalentsListV2 = getEquivalent_V(V2);
        // console.log("EquivalentsList V2:",EquivalentsListV2);
        // for (var elem in EquivalentsListV2) {
        //     console.log(EquivalentsListV2[elem]);
        //     if ( areEqual(V0, EquivalentsListV2[elem].matrix) ){
        //         console.log("egale");
        //     }
        // }


        //on pose un premier carr√© fixe de 100px de large au centre de la zone de simu

        // const black = "stroke:black;stroke-width:3;fill-opacity:0;"
        // const red = "stroke:red;stroke-width:1;fill-opacity:0;"
        // let boxA = {xmin:100, xmax: 200, ymin:80, ymax:160};
        // drawBox(boxA,black);
        // for (let i=0;i<15;i++){ 
        //     for (let j=0;j<15;j++){ 
        //         let xmin = 28 * i;
        //         let ymin = 38 * j;
        //         let boxB = {xmin, xmax: xmin+28, ymin, ymax:ymin+38};
        //         if ( testBoxesOverlapping(boxA, boxB) )  {
        //             drawBox(boxB,red);
        //         }
        //     }
        // }

    </script>
    <style>
        #main-container {
            display:flex;
            flex-direction: column;
        }
        #run-btn{
            width: 60px;
            height: 36px;
            margin: 10px 10px 10px 0;
        }

        #menu{
            display: flex;
            flex-direction: column;
        }
    </style>
</body>

</html>
