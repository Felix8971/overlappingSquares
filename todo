
- Lancer des calculs en faisant diminuer progressivement les parametres step, pas angulaire, etc 
jusqu'a convergeance du nombre d'arrangements.

idee: regrouper moveto, rotate et resize en une seule fonction qui prend:
   - position x,y du centre du carre
   - size
   - angle rotation
==> done

idee optimisation: separer arrsN3 en plusieurs parties ==> done

arrsN3 devient un array a 2 dimensions arrsN3[i][j]
- i correspond au nombre entier obtenu en faisant la somme de chaque colonne de V puis un tri croissant
- j correspond au nombre entier obtenu en faisant la somme de chaque colonne de I puis un tri croissant

- ecrire le code pour creer les svg a partir du fichier arrangments-found-*.json

- creer les tests avec Jest 

- optimisation: ne faire bouger qu'un seul carre à la fois afin de ne pas 
   recalculer inutilement les intersections entre les deux autres carres

- mettre en place un outil qui va permettre de charger chaque arrangments trouvé et de le rectifier 
  sans changer les matrice V et F afin de rendre le svg plus facile a visualiser (sans avoir a zoomer).
  A chaque step mettre en place un syteme qui controle si V et F restent constants et ne pas autoriser 
  la modification. Creer un bouton pour mettre à jour le fichier svg de l'arrangement. 
==> done 

- mettre en place un outil qui va permettre de charger la liste des arrangments trouvés et de
 construire un nouvel arrangement a la main pour verifier si il est dans la liste 
==> done

- Ajouter un button "image miroir" a la palette de transformations + rotation d'ensenble des carrés

- idee new projet: intersection de segments (position centre, tailles et angles variables)
- idee new projet: calculer le nombre d'arrangements possibles de n polygones reguliers convexes:
triangles equilaterals, carrés, pentagones, hexagone, etc.
Voir si il exite une formule U(n) = ...
Ways to intersect regular convex polygons

- ecrire une fct qui renvoie false si 2 segments ne se croisent pas sinon renvoyer le point d'intersection: done
=> done

N=2 avec rotation et resize: 12
N=2 sans resize avec rotation: donne 7 arr
N=2 sans rotation avec resize: donne 4 arr
N=2 sans rotation et sans resize: donne 1 arr

N=3 donne ... arr (>= 4337)
N=3 sans resize avec rotation:: donne 457 arr (la rotation a un impact fort sur le nombre d'arrangement trouvés)
N=3 sans rotation avec resize: donne 47 arr
N=3 sans rotation et sans resize: donne 6 arr

http://www.ams.org/publicoutreach/feature-column/fc-2019-01
https://www.researchgate.net/publication/321604192_Arrangements_of_Pseudocircles_On_Circularizability


Faire un calcul complementare pour chaque arr n3 deja trouvés: 
- enlever un des carré 
- puis detecter tous les polygons et y introduire un carré de taille nulle afin de 
verifier si on a pas oublié certaines configurations. 

Relancer le calcul (en mode reprise) entre 0 et 5% avec des pas plus fins et voir 
si on trouve de nouveaux arrangements

Lancer un premier calcul avec des carrés de tailles similaires afin qu'ils soient plus presentables 
graphiquement. Puis utiliser la proprieté viewBox dans la balise svg afin de zoomer
 sur la partie interressante ?

Ajouter une option plein ecran avec zoom et translation ?

Ajouter option pour verouiller ou non un arrangment.
Si non verouillé et que l'on construit un arrangement deja connu afficher son numero.
sinon afficher un message pour dire qu'il est nouveau.

Ajouter un outil pour filtrer les arrangment sur certains criteres.
il y a un bug sur la rotation


ajouter spinner pendant le chargement des arrangements (car un peu long au premier chargement) 
reduire taille json

à lire :
https://en.wikipedia.org/wiki/Combinatorial_explosion

https://pdfs.semanticscholar.org/1fc5/1e1edc64b2d634e3cc37b86154dc90b37721.pdf

https://www.quantamagazine.org/the-math-problem-with-pentagons-20171211/